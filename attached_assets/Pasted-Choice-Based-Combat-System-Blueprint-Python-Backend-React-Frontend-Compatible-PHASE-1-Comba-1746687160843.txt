Choice-Based Combat System Blueprint (Python Backend + React Frontend Compatible)
ğŸ§± PHASE 1 â€” Combat Initialization
ğŸ”¹ Step 1.1 â€” Trigger Encounter

    Called when narrative or logic initiates combat.

ğŸ”¹ Step 1.2 â€” Build Initial Combat State

Define:

combat_state = {
    "location": "Ancient Crypt",
    "round": 1,
    "momentum": "player",
    "environment": ["Low Light", "Arcane Interference"],
    "enemies": [EnemyObject("Flesh Mage")],
    "player": PlayerObject(...),
    "growth_log": [],
    "log": [],
    "phase": "decision",
    "available_actions": []
}

ğŸ§  PHASE 2 â€” Generate Combat Options
ğŸ”¹ Step 2.1 â€” Analyze Player Context

    Inventory

    Known spells

    Domain values

    Active status effects

    Tag unlocks

ğŸ”¹ Step 2.2 â€” Build 3â€“5 Action Options + Custom Input

    Call: generate_combat_options(player, combat_state)

    Output: array of action objects

{
  "label": "Cast 'Blinding Spark'",
  "action_type": "spell",
  "domains": ["MIND", "SPIRIT"],
  "cost": 1,
  "tags": ["Stun", "Light"]
}

âœ… Send to frontend â†’ render as UI buttons + text area
ğŸ² PHASE 3 â€” Action Selection & Roll Resolution
ğŸ”¹ Step 3.1 â€” Player Chooses Action

Frontend sends JSON:

{
  "chosen_action": {
    "label": "Cast 'Blinding Spark'",
    "action_type": "spell",
    "domains": ["MIND", "SPIRIT"],
    "target": "Flesh Mage"
  }
}

ğŸ”¹ Step 3.2 â€” Backend Executes:

roll = d20() + sum([player.domain[d] for d in action["domains"]])
dc = calculate_dc(enemy, terrain_mods, momentum)
outcome = roll >= dc

ğŸ”¹ Step 3.3 â€” Build Combat Log Entry

log_entry = f"ROLL 1d20 + {domain_sum} = {roll} vs DC {dc} â†’ {'SUCCESS' if outcome else 'FAILURE'}"
combat_state["log"].append(log_entry)

ğŸ”¹ Step 3.4 â€” Update Growth Log

growth_log.append({
    "domain": "MIND",
    "result": "success",
    "roll": 17,
    "dc": 15,
    "action": "Blinding Spark"
})

ğŸ©¸ PHASE 4 â€” Apply Effects & Enemy Response
ğŸ”¹ Step 4.1 â€” Apply Damage, Status, or Narrative Effect

    Apply HP loss, status effect, or momentum change

    Modify enemy state accordingly

ğŸ”¹ Step 4.2 â€” Trigger Enemy Turn

    Run generate_enemy_action(enemy, player, state)

    Perform enemy logic the same way (rolls, log, growth, outcomes)

ğŸ” PHASE 5 â€” Advance Round & Loop
ğŸ”¹ Step 5.1 â€” Increment Round

combat_state["round"] += 1
combat_state["momentum"] = "enemy" if last_actor == "player" else "player"

ğŸ”¹ Step 5.2 â€” Check End Conditions

if player.hp <= 0:
    trigger_death_scene()
elif all(e.hp <= 0 for e in enemies):
    trigger_victory_scene()
else:
    regenerate_player_options()

ğŸ§  PHASE 6 â€” Memory, Reflection, Growth
ğŸ”¹ Step 6.1 â€” Log Domain Growth

Push growth_log to LangChain or vector memory.
ğŸ”¹ Step 6.2 â€” Reflective Event Trigger

if player.SPIRIT >= 6 and failed_escape:
    trigger_reflection("Why did I panicâ€¦ again?")

